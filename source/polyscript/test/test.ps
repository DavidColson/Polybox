// Blocks
{
    // Basic expressions
    dave := 3*12.3/8+1;

    dave = 2.0;
    print(dave);
    testBool: bool;
    testBool = true;
    print(testBool);
    // If statements
    tester:= 7;
    lucy:= 0;
    if tester < 5 && lucy == 0 {
        lucy = 10;
    } else if tester == 5 {
        lucy = 27;
    } else {
        lucy = 20;
    }
    print(lucy);

    // Types as first class values
    myType:Type = i32;
    print(myType);

    myTypeType := Type;
    print(myTypeType);

    funcType := fn (i32, f32) -> i32;
    print(funcType);

	// Type casting
	castValue := as(i32) 5.0 * 12 + 4;
	print(castValue);
}


// What should codegen do when it encounters a struct definition expression?
// Push a type instance onto the stack?
// For a non const yes, but for a const absolutely not
// Ugh we need constants
BabysFirstStruct := struct {
	boolMember: bool;
	floatMember: f32;
	intMember: i32;
};

firstInstance : BabysFirstStruct;

firstInstance.boolMember = false;
firstInstance.floatMember = 1337.0;
firstInstance.intMember = 5;

print(firstInstance.boolMember);
print(firstInstance.floatMember);
print(firstInstance.intMember);

SecondStruct := struct {
	floatMember: f32;
	intMember: i32;
	innerStruct: BabysFirstStruct;
};

secondInstance : SecondStruct;
secondInstance.floatMember = 420.0;
secondInstance.intMember = 22;
secondInstance.innerStruct = firstInstance;

print(secondInstance.floatMember);
print(secondInstance.innerStruct.floatMember);

// Functions
add := func (num: i32, float: f32, boolean: bool) -> i32 {
    print(num);
    print(float);
    print(boolean);
    
    result := 0;
    result = 5+2;
    return result;
};

print(add(5, 55.2, true));

// Recursion
fibonacci := func (n: i32) -> i32 {
    if (n <= 1)
        return n;
    else
        return fibonacci(n-1) + fibonacci(n-2);
};

// Loops
nTerms := 4;
n := 0;
while n < nTerms {
    print(fibonacci(n));
    n = n+1;
}
